# Lab 2

## Testing functions

- **lesson 5** - `bagPacking`
- **lesson 6** - `firstDuplicateIndex `
- **lesson 7** - `alignFileByWidth`

# Lab 3

Для данной работы использовался Gradle-плагин [Kotlinx-Kover](https://github.com/Kotlin/kotlinx-kover).

Результаты можно представить в формате HTML.

### Overall Coverage Summary

| Package     | Class, %   | Method, %  | Branch, %     | Line, %      | Instruction, % |
| ----------- | ---------- | ---------- | ------------- | ------------ | -------------- |
| all classes | 100% (5/5) | 100% (6/6) | 87,2% (75/86) | 100% (89/89) | 99,7%(869/872) |

### Coverage Breakdown

| Package       | Class, %   | Method, %  | Branch, %     | Line, %      | Instruction, %  |
| ------------- | ---------- | ---------- | ------------- | ------------ | --------------- |
| lesson5.task1 | 100% (3/3) | 100% (3/3) | 89,5% (34/38) | 100% (36/36) | 100% (452/452)  |
| lesson6.task1 | 100% (1/1) | 100% (1/1) | 83,3% (5/6)   | 100% (11/11) | 100% (76/76)    |
| lesson7.task1 | 100% (1/1) | 100% (2/2) | 85,7% (36/42) | 100% (42/42) | 99,1% (341/344) |

- `Class` – количество протестированных классов; поскольку целью было протестировать одну функцию, данный показатель итак макимален, т.к. затрагивает эту единственную функцию; исключением является `lesson5`, где помимо тестируемой функции используются 2 класса, которые однако также были задействованы.
- `Method` – аналогично предыдущему.
- `Branch` – обозначает пократие дерева условных выражений, т.е. количество протестированных кейсов из всех возможных ветвлений `if else`. Чтобы улучшить данный показатель нужно определить, какие ветвления еще не были протестированы и задать входные данные, генерирующие данные ветвления.
- `Line` – количество строк, используемых в тестах.
- `Instruction` – то ж самое, что и предыдущее, но подсчет ведется в ассемблерных инструкциях.

# Lab4

Для данной работы использовался фаззер [Jazzer](https://github.com/CodeIntelligenceTesting/jazzer). Обвязка находится в `lessonXX.fuzzer`, представляет из себя статические объекты, содержащую функцию `fuzzerTestOneInput`. Данная функция получает на вход провайдер случайных данных `FuzzedDataProvider`, который может быть преобразован в любой примитив, строку или коллекцию. С этими данными на вход и вызывается функцию под тестом.

Для запуска использовался Docker-image:

```powershell
docker run -v D:\Poly\Testing\testing-labs\build\libs:/fuzzing cifuzz/jazzer "-runs=1000" "--cp=testing-labs.jar" --target_class="lesson5.fuzzing.BagPackingFuzzerTarget"
```

```powershell
docker run -v D:\Poly\Testing\testing-labs\build\libs:/fuzzing cifuzz/jazzer "-runs=10000" "--cp=testing-labs.jar" --target_class="lesson6.fuzzing.ParseFuzzerTarget"
```

```powershell
docker run -v D:\Poly\Testing\testing-labs\build\libs:/fuzzing cifuzz/jazzer "-runs=10000" "--cp=testing-labs.jar" --target_class="lesson7.fuzzing.FilesFuzzerTarget"
```

Основной показатель, на который можно смотреть – `cov`  (Total number of code blocks or edges covered by executing the current corpus). Чем он больше - тем лучше.

В ходе саого фаззинга логировалось следующее:

- `INITED` – инициализация фаззера
- `pulse` – каждые 2<sup>n</sup> итераций, чтоб было понятно, что фаззер работает
- `NEW` – фаззер нашёл комбинацию, покрывающую непокрытые на данные моменту частки кода
- `REDUCE` – фаззер нашёл комбинацию покороче, покрывающую уже имеющиеся участки кода
- `DONE` – фаззер закончил работу

По итогам прогона фаззер может вывести 2 типа заключений:

- комбинации, обеспечивающие повышенное покрытие
- баг (исключение), из-за котоого фаззер прекратил тестирование досрочно

Данный фреймворк довольно таки удобен благодаря тому, что его можно запускать через docker, кроме того, как показано далее, он может находить вполне себе валидные комбинации для повышения покрытия, количество которых зависит от времени (очень большого времени, т.к. это слабый оракул).

## lesson5

Мне не удалось полностью прогнать тесты, т.к. фаззер ловил 2 типа бага

- `NegativeArraySizeException`
- `OutOfMemoryError`

Соответствующие отчеты, которые вызывают данный баг, находятся в `results/fuzzing/lesson5`. Там же можно найти полный лог.

## lesson6

Здесь фаззер смог выдать две комбинации, повышающие покрытие. Багов за несколько прогонов по 10000 тестов найти не удалось.

## lesson7

Нашел одну комбинацию, в остальном все аналогично предыдущему тестингу.

